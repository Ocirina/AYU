package nl.codecup.src;

public class Player {
	private GameState state;
	public static int piece;
	public static int empty = 0;
	private Referee referee;

	public Player(GameState state, int piece, Referee referee) {
		this.state = state;
		this.piece = piece;
		this.referee = referee;
	}

	private Referee getReferee() {
		return this.referee;
	}

	public GameState takeTurn(GameState state) {
		if (state.isGameOver()) {
			return state;
		}

		this.state = state.clone();
		this.piece = state.getPlayingPiece();
		Move move = chooseMove();
		if (this.getReferee().validMove(move)) {
			IO.output(move.toString());
			return state.makeMove(move);
		}

		IO.debug("NO VALID MOVE! " + move.toString());

		return null;
	}

	/**
	 * Generate random move, in the future this will be a move which is
	 * generated by monte carlo
	 * 
	 * @return
	 */
	public Move chooseMove() {
		int[][] content = this.state.getBoardContents();
		int contentLength = content.length - 1;
		int[] rows = new int[] { 0, 1, 2, 10, 9, 8, 3, 4, 7, 6, 5 };
		// Strategy 1: Make long groups in each column. (Should make a group of
		// 6 on each row).
		for (int row : rows) {
			for (int column = 0; column < contentLength; column++) {
				IO.debug("row: " + row + ", column: " + column + " => "
						+ content[row][column]);

				/**
				 * Situation 1 Start: | | W | | W | | | Result: | | | W | W | |
				 * |
				 * 
				 * Situation 2 Start: | | W | W | | W | | Result: | | | W | W |
				 * W | |
				 * 
				 * Start: | | | W | W | W | | W | | Result: | | | | W | W | W |
				 * W | |
				 */
				boolean gapScenario = (column < 9 && row < 9
						&& content[row][column] == Player.piece
						&& content[row][column + 1] == 0 
						&& content[row][column + 2] == Player.piece);

				int columnPieceToMove = 0;
				if (gapScenario) {
					for (int i = column; i > 0; i--) {
						// IO.debug("DEBUG: " + content[row][i + 1]);
//						IO.debug("C: " + i + " => " + content[row][i]);
						if (content[row][i] != Player.piece) {
//							IO.debug("test");
							columnPieceToMove = i-1;
							break;
						} 
//						else {
//							break;
//						}
					}
//					IO.debug("column Piece" + columnPieceToMove);

				
				if (gapScenario) {
					int columnPieceToMove = findLastPieceInTheRow(content, row,	column, 0);
					return new Move(row, columnPieceToMove, row, column + 1);
				}
			}
		}
		
		for (int row : rows) {
			for (int column = 0; column < contentLength; column++) {
				boolean gapScenario = (column <= 9
						&& content[row][column] == Player.piece
						&& content[row][column + 1] == 0);
				
				if (gapScenario) {
					int columnPieceToMove = findLastPieceInTheRow(content, row,	column, 0);

					return new Move(row, columnPieceToMove, row, column + 1);
				}
			}
			IO.debug("\n");

		}

		// Strategy 2: If there are no more possibilities of making a group on a
		// column.
		// Connect them.
		/**
		 * Situation:
		 * 

		 * Start: | | | W | W | W | W | W | W | | | | | | | | | | | | | W | W |
		 * W | W | W | W |

		 * Start: 
		 * |   |   | W | W | W | W | W | W | 
		 * |   |   |   |   |   |   |   |   |
		 * |   |   | W | W | W | W | W | W | 

		 * 
		 * Result:
		 * |   |   |   | W | W | W | W | W | 
		 * |   |   |   |   |   |   |   | W |
		 * |   |   | W | W | W | W | W | W | 
		 * 
		 */

		return move;

		for (int row = 1; row < (contentLength-1); row++) {
			if (content[row][10] == 0) {
				IO.debug("Got it!");
				int columnPieceToMove = findLastPieceInTheRow(content, row,	10, 5);
				return new Move((row -1), columnPieceToMove, row, 10);
			}
		}
		return null;
	}

	private int findLastPieceInTheRow(int[][] content, int row, int column, int defaultColumn) {
		int columnPieceToMove = defaultColumn;
		for (int i = column; i > 0; i--) {
			if (content[row][i] == Player.piece)
				columnPieceToMove = i;
			else
				break;
		}
		return columnPieceToMove;

	}

	public void stop() {
	}

	/**
	 * Method to tell caiaio which player ours is
	 */
	public String toString() {
		return "R player: " + Player.piece;
	}

}
