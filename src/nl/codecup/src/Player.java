package nl.codecup.src;

import java.util.Random;

public class Player {
    private GameState state;
    public static int piece;
    public static int empty = 0;
    private Referee referee;

    public Player(GameState state, int piece, Referee referee) {
        this.state = state;
        Player.piece = piece;
        this.referee = referee;
    }

    public GameState takeTurn(GameState state) {
        if (state.isGameOver()) {
            return state;
        }

        this.state = state.clone();
        // Player.piece = state.getPlayingPiece();
        Move move = chooseMove();
        // if (this.getReferee().validMove(move)) {
        IO.output(move.toString());
        return state.makeMove(move);
        // }

        // Let program quit, more easy debugging.
        // IO.output("NO VALID MOVE: " + move.toString());

        // return null;
    }

    /**
     * get's a random move
     * 
     * @return Move
     */
    public Move getRandomMove() {
        IO.debug("TRY TO FIND RANDOM MOVE!");
        Group[] remainingGroups = this.state.getGroups();
        int groupIndex = randomInt(0, remainingGroups.length - 1);

        Group startGroup = remainingGroups[groupIndex];
        String[] shortestPath = PathFinder.getInstance().findShortestPathForGroup(state.getGroups(), state.getBoard(), startGroup);
        if (shortestPath != null) {
            String sPath = "";
            for (String s : shortestPath) {
                sPath += s + " ";
            }
            IO.debug("Found path: " + sPath);
            return constructMoveFromShortestPath(startGroup, shortestPath);
        }
        return getRandomMove();
    }

    /**
     * constructs a move based on the shortest path between two groups
     * 
     * @param startGroup
     * @param shortestPath
     * @return Move
     */
    private Move constructMoveFromShortestPath(Group startGroup, String[] shortestPath) {
        int targetX = Integer.parseInt(shortestPath[0].split(",")[0]);
        int targetY = Integer.parseInt(shortestPath[0].split(",")[1]);

        String[] origin = startGroup.findPointMostFarAway(targetX, targetY, this.state.getBoard());
        int originX = Integer.parseInt(origin[0]);
        int originY = Integer.parseInt(origin[1]);

        if (this.state.getBoardContents()[originX][originY] != Player.piece) {
            return getRandomMove();
        }
        return new Move(originX, originY, targetX, targetY);
    }

    /**
     * get a random number between the min and max parameters
     * 
     * @param min
     * @param max
     * @return random number
     */
    private int randomInt(int min, int max) {
        Random rand = new Random();
        return rand.nextInt((max - min) + 1) + min;
    }

    /**
     * Generate random move, in the future this will be a move which is
     * generated by monte carlo
     * 
     * @return
     */
    public Move chooseMove() {
        int[][] content = this.state.getBoardContents();
        int contentLength = content.length - 1;
        this.state.recheckGroups();
        IO.debug("TRY TO FIND MOVE FOR PLAYER: " + Player.piece);

        if (state.getGroupsLength() > 18) {
            for (int row = 0; row < contentLength; row++) {

                // bottom -> up until the half of the column
                for (int column = 0; column < contentLength; column++) {
                    boolean gapScenario = (column < 9 && row < 9 && content[row][column] == Player.piece && content[row][column + 1] == 0 && content[row][column + 2] == Player.piece);

                    if (gapScenario) {
                        int columnPieceToMove = findLastPieceInTheRow(content, row, column, 0);
                        return new Move(row, columnPieceToMove, row, column + 1);
                    }
                }

                //

            }
        } else {
            return getMonteCarloMove();
        }

        return getRandomMove();
    }

    private Move getMonteCarloMove() {
        MCTree tree = new MCTree(4, 4, this);
        return tree.getBestMove().getState().getPlayedMove();
    }

    /**
     * Find the last piece of a row
     * 
     * @param content
     * @param row
     * @param column
     * @param defaultColumn
     * @return
     */
    private int findLastPieceInTheRow(int[][] content, int row, int column, int defaultColumn) {
        int columnPieceToMove = defaultColumn;
        for (int i = column; i > 0; i--) {
            if (content[row][i] == Player.piece)
                columnPieceToMove = i;
            else
                break;
        }
        return columnPieceToMove;
    }

    /**
     * Method to tell caiaio which player ours is
     */
    public String toString() {
        return "R player: " + Player.piece;
    }

    public GameState getState() {
        return this.state;
    }

}
