package nl.codecup.src;

public class Player {
	private GameState state;
	private IPathFinder pathFinder = new AStarPathFinder();
	public static int piece;

	public Player(GameState state, int piece) {
		this.state = state;
		Player.piece = piece;
	}

	public GameState takeTurn(GameState state) {
		if (state.isGameOver()) {
			return state;
		}

		this.state = state.clone();
		// Player.piece = state.getPlayingPiece();
		Move move = chooseMove();
		// if (this.getReferee().validMove(move)) {
		IO.output(move.toString());
		return state.makeMove(move);
		// }

		// Let program quit, more easy debugging.
		// IO.output("NO VALID MOVE: " + move.toString());

		// return null;
	}

	/**
	 * Generate random move, in the future this will be a move which is
	 * generated by monte carlo
	 * 
	 * @return
	 */
	public Move chooseMove() {
		Move move = null;

		this.state.recheckGroups();
		IO.debug("TRY TO FIND MOVE FOR PLAYER: " + Player.piece);
		IO.debug("AMOUNT OF GROUPS: " + state.getGroupsLength());

		if (move == null && state.getGroupsLength() > 15) {
			move = new DirectionAlgorithm(state).getMove();
		}
		if (move == null && state.getGroupsLength() > 10) {
			move = getMonteCarloMove(2, 4, new RandomMoveAlgorithm(state,
					pathFinder));
		}
		if (move == null && state.getGroupsLength() > 5) {
			move = getMonteCarloMove(5, 1, new RandomMoveAlgorithm(state,
					pathFinder));
		}
		if (move == null) {
			move = new RandomMoveAlgorithm(state, pathFinder).getMove();
		}

		return move;
	}

	private Move getMonteCarloMove(int width, int height, IAlgorithm algorithm) {
		MCTree tree = new MCTree(width, height, state, algorithm);
		return tree.getPlayableMove();
	}

	/**
	 * Method to tell caiaio which player ours is
	 */
	public String toString() {
		return "R player: " + Player.piece;
	}

	public GameState getState() {
		return this.state;
	}

}
